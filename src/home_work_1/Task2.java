package home_work_1;

public class Task2 {

    static int a = 2; //для примера №3
    static int b = 2, c = 8; // для применра №4
    static int d = 2, e = 8; //для примера №5
    static int f = 2, g = 8; //для примера №6
    static int h = 2, i = 8; //для примера №7

    static int result1 = 5 + 2 / 8;
         /*
        result1 = 5. Сначала выполняется операция деления. Т.к операция деления проведена над
        числами типа int, то дробная часть просто отбрасывается.
        Результат деления равен 0.
        Затем 5 + 0 = 5
        */

    static int result2 = (5 + 2) / 8; /*
        result2 = 0. Сначала выполняется сложение в скобках. Получается 7.
        Затем 7/8. Т.к деление над целыми числами, то дробная часть отбрасывается и получается 0.
        */

    static int result3 = (5 + a++) / 8; /*
        В выражении используется а = 2, и после использования 'а' увеличивается на 1(3).
        5+2 = 7 -> 7/8 -> отбрасывается дробная часть. Результат равен 0.
        */

    static int result4 = (5 + b++) / --c; /*
        В выражении используется b = 2, после использования b увеличивается на 1(3).
        Переменная 'с', равная 8, перед использованием уменьшается на 1(7).
        (5 + 2) / 7. Результат равен 1.
        */

    static int result5 = (5 * 2 >> d++) / --e; /*
        Значение d берётся равным 2, а после использования увеличивается на 1(3).
        Значение 'е'(8) перед использованием уменьшается на 1 (7).
        (5 * 2 >> 2) / 7 ->
        (10 >> 2) / 7
        10 в двоичной системе это 1010, сдвиг на две позиции вправо первращает число в 0010, а это 2 в десятичной,
        т.о имеем 2/7. Результат с отбрасыванием дробной части равен 0.
        */

    static int result6 = (5 + 7 > 20 ? 68 : 22 * 2 >> f++) / --g; /*
        Инкремент и декремент имеют здесь высший приоритет.
        Значение 'f' будет взято 2 для использования в выражении, а затем будет увеличено на 1
        Значение 'g' сразу уменьшится на 1, а затем будет использовано в выражении (7).
        Далее выполняться операции те, что в скобках в порядке: 22*2 = 44 -> 5+7 = 12 -> 44 >> 2 = 11
        Получится выражение: (12 > 20 ? 68 : 11) / 7
        В скобках значение будет равно 11, т.к тернарный оператор пойдёт по ветке false
        11/7 с отбрасывание дробной части булет равно 1.
        */

    //int result7 = (5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> h++) / --i;
        /*
        Возникает ошибка компиляции, т.к в ветке true тернарного оператора результат типа boolean. Поэтому
        в теории может возникнуть исключительная ситуация попытки деления типа boolean на целочисленный тип.
        Хотя в данном конкретном случае тернарный оператор пойдёт ао ветке false, но это ничего не меняет, всё равно
        возникает ошибкка компиляции.
        */

    static boolean result8 = 6 - 2 > 3 && 12 * 12 <= 119; /*
        Сразу выполнятся все арифметические действия.
        Получим 4 > 3 && 144 <= 119.
        Затем выполняются операторы сранения, результатом которых будет тип boolean.
        Получим true && false.
        Результатом сокращённого оператора И данном случае будет false.
        */

    static boolean result9 = true && false; /*
        Результатом сокращённого оператора И данном случае будет false.
        */

    public static void main(String[] args) {

        System.out.println("Результат выражения 1: " + result1);
        System.out.println("Результат выражения 2: " + result2);
        System.out.println("Результат выражения 3: " + result3 + ", " + "a = " + a);
        System.out.println("Результат выражения 4: " + result4 + ", " + "b = " + b + ", " + "c = " + c);
        System.out.println("Результат выражения 5: " + result5 + ", " + "d = " + d + ", " + "e = " + e);
        System.out.println("Результат выражения 6: " + result6 + ", " + "f = " + f + ", " + "g = " + g);
        System.out.println("Результат выражения 7: " + "Ошибка компиляции");
        System.out.println("Результат выражения 8: " + result8);
        System.out.println("Результат выражения 9: " + result9);
    }
}
